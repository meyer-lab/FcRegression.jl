"""
Guidance on DataFrame handling:
1. First thing first: DataFrame is different from Matrix!
2. All saved .csv files must be a valid dataframe (explained below) when
    imported by a one-line read command (delim = ',', comment = "#", etc.)
3. No two columns shall bear the same name (especially in csv files)
4. Keep the row indices (1,2,3,...) auto-generated by the import function
5. Use long format to store those with replicates
6. Use consistent name in all .csv files
    (e.g. never have both "FcgRI" and "FcgR1", even in different files)
7. Check/sort/reorder the order of rows and cols whenever that matters
"""

using DataFrames
using CSV
import StatsBase

const KxConst = 6.31e-13 # 10^(-12.2)

function geocmean(x)
    x = convert(Vector, x)
    x[x .<= 1.0] .= 1.0
    return StatsBase.geomean(x)
end

cellTypes = [:ncMO, :cMO, :NKs, :Neu, :EO]
murineIgG = [:IgG1, :IgG2a, :IgG2b, :IgG3]
humanIgG = [:IgG1, :IgG2, :IgG3, :IgG4]
murineFcgR = [:FcgRI, :FcgRIIB, :FcgRIII, :FcgRIV]
humanFcgR = [:FcgRI, :FcgRIIA, :FcgRIIB, :FcgRIIC, :FcgRIIIA, :FcgRIIIB]
humanFcgR1 = [:FcgRI, Symbol("FcgRIIA-131H"), Symbol("FcgRIIB-232I"), Symbol("FcgRIIC-13N"), Symbol("FcgRIIIA-158F"), :FcgRIIIB]
murineActI = [1, -1, 1, 1]
humanActI = [1, 1, -1, 1, 1, 1]

function importRtot(; murine = true)
    if murine
        df = CSV.read("../data/murine-FcgR-abundance.csv")
    else
        df = CSV.read("../data/human-FcgR-abundance.csv")
    end
    df = aggregate(df, [:Cells, :Receptor], geocmean)
    df = unstack(df, :Receptor, :Cells, :Count_geocmean)
    df[!, :Receptor] = map(Symbol, df[!, :Receptor])
    df = df[in(murine ? murineFcgR : humanFcgR).(df.Receptor), :]
    return convert(Matrix{Float64}, df[!, cellTypes])
end


""" Import human or murine affinity data. """
function importKav(; murine = true, c1q = false, retdf = false)
    if murine
        df = CSV.read("../data/murine-affinities.csv", comment = "#")
    else
        df = CSV.read("../data/human-affinities.csv", comment = "#")
    end

    if c1q == false
        df = filter(row -> row[:FcgR] != "C1q", df)
    end

    df = stack(df; variable_name = :IgG, value_name = :Kav)
    df = unstack(df, :FcgR, :Kav)
    df = df[in(murine ? murineIgG : humanIgG).(df.IgG), :]

    if retdf
        return df
    end

    return convert(Matrix{Float64}, df[!, murine ? murineFcgR : humanFcgR1])
end


""" Import cell depletion data. """
function importDepletion(dataType; c1q = false)
    if dataType == "ITP"
        filename = "../data/nimmerjahn-ITP.csv"
    elseif dataType == "blood"
        filename = "../data/nimmerjahn-CD20-blood.csv"
    elseif dataType == "bone"
        filename = "../data/nimmerjahn-CD20-bone.csv"
    elseif dataType == "melanoma"
        filename = "../data/nimmerjahn-melanoma.csv"
    else
        @error "Data type not found"
    end

    df = CSV.read(filename, delim = ",", comment = "#")
    df[!, :Condition] = map(Symbol, df[!, :Condition])
    df[!, :Target] = 1.0 .- df[!, :Target] ./ 100.0

    affinityData = importKav(murine = true, c1q = c1q, retdf = true)
    df = join(df, affinityData, on = :Condition => :IgG, kind = :inner)

    df[df[:, :Background] .== "R1KO", :FcgRI] .= 0.0
    df[df[:, :Background] .== "R2KO", :FcgRIIB] .= 0.0
    df[df[:, :Background] .== "R3KO", :FcgRIII] .= 0.0
    df[df[:, :Background] .== "R1/3KO", [:FcgRI, :FcgRIII]] .= 0.0
    df[df[:, :Background] .== "R4block", :FcgRIV] .= 0.0
    df[df[:, :Background] .== "gcKO", [:FcgRI, :FcgRIIB, :FcgRIII, :FcgRIV]] .= 0.0
    return df
end
